一种广泛的类型,把明确数据类型的工作提前到了编译时期,借鉴了数组的特点(将类型的明确集中到了主函数,提高了代码的可读性和复用性)
泛型好处:
                避免了数据转换问题

                减少了黄色警告线

                可以简化代码

package  泛型 ;
public   class   Test   {
public   static   void   main ( String []   args )   {
     Test01 < String ,   Integer >   a = new   Test01 < String ,   Integer > () ;
    
}
public   static   < e > void   sell ( e   b ){ //当泛型在方法中使用时表示声明了一种引用类型 的泛型 (作为数据 类型使用)
     System . out . println ( b ) ;
    
}

package  泛型 ;
public   class   Test01 < e , t >   {
     public   void   sleep ( e   a , t   q ){
         System . out . println ( a ) ;
         System . out . println ( q ) ;
     }
     public   Test01 ()   {
         super () ;
         //  TODO  Auto-generated constructor stub
     }
}

}


泛型的功能:提高了系统的安全性:确保了程序在编译时期的安全
          好处:将运行是问题:ClassCastException转到编译时期( !!!!!!!!!!!!!!!!!!!!!!!!!)
                    避免流前置转换的麻烦
<>:当操作引用类型数据不确定时.用.将要操作的引用书记类型传入即可.其实<>就是用于结束具体引用数据类型的参数范围      

运行时.泛型将会擦出--------即编译器生成的.class文件不带泛型(这被称为泛型的擦出==为了兼容类加载器)
泛型补偿:在运行时,通过获取元素类型进行转换操作.不用使用者强转了
泛型是给编译器使用的技术,用于编译时期,为确保安全.
运行是会将泛型去掉,生成的class文件不带泛型,所以使用反射产生的类,方法不带泛型
泛型的补偿,在编译的时候,会根据传入的数据的泛型进行转换
<?>通配符(用在类型不明确且仅在不对类型继续操作时)
泛型在书写程序时要先明确,提高代码的安全性,目的性
泛型定义了参数(类后,方法上)返回值前修饰符号后面
但方法静态时,不能访问类上定义的泛型.如果静态方法使用泛型,只能将泛型定义在方法上
泛型声明和实体必须一致
<? extends Object>泛型的限定`==<?>     上限                
<? super E>接收E或E的父类                    下限//一般用于比较器,因为比较器的对象一般为集合中所有数据的父类类型


